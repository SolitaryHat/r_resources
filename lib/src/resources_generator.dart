import 'dart:async';
import 'dart:io';

import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:yaml/yaml.dart';
import 'package:path/path.dart' as path;

const _defaultGeneratedClassName = 'R';
const _defaultGeneratedClassPath = 'lib';
const _defaultSourceFilesDirName = 'lib/';
const _optionsFileName = 'flutter_resources_options.yaml';
const _pubspecFileName = 'pubspec.yaml';
const _generatedFileHeader =
    '/// THIS FILE IS GENERATED BY flutter_resources. DO NOT MODIFY MANULLY.';

const _ignoreCommentForLinter = '// ignore_for_file: '
    'always_specify_types,'
    'lines_longer_than_80_chars,'
    'prefer_double_quotes';

final _identifierRegExp = RegExp(r'^([(_|$)a-zA-Z]+([_a-zA-Z0-9])*)$');
final _invalidIdentifierCharecatersRegExp = RegExp(r'[^_a-zA-Z0-9]+');

class _GeneratorOptions {
  const _GeneratorOptions._({
    this.className = _defaultGeneratedClassName,
    this.path = _defaultGeneratedClassPath,
  });

  factory _GeneratorOptions() => const _GeneratorOptions._();

  factory _GeneratorOptions.fromYamlMap(YamlMap yamlMap) {
    return _GeneratorOptions._(
      className: yamlMap['className'] as String ?? _defaultGeneratedClassName,
      path: yamlMap['path'] as String ?? _defaultGeneratedClassPath,
    );
  }

  final String className;
  final String path;

  bool get isPathCorrect =>
      path == _defaultGeneratedClassPath ||
      path.startsWith(_defaultSourceFilesDirName);

  String get classFileName => '${className.toLowerCase()}.dart';
}

class ResourcesBuilder implements Builder {
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final pubspecYamlMap = await _createPubspecYampMap(buildStep);
    if (pubspecYamlMap?.isEmpty ?? true) return;

    final options = _generatorOptions;
    if (!options.isPathCorrect) {
      log.severe(
          'Overriden path from $_optionsFileName shuld start with "lib/"');
      return;
    }

    final rClass =
        await _generateRFileContent(buildStep, pubspecYamlMap, options);
    log.info('CLASS = $rClass');
    if (rClass.isEmpty) return;

    final dir = options.path.startsWith('lib') ? options.path : 'lib';
    final output = AssetId(buildStep.inputId.package, path.join(dir, 'r.dart'));
    return buildStep.writeAsString(output, rClass);
  }

  @override
  Map<String, List<String>> get buildExtensions {
    final options = _generatorOptions;
    var extensions = options.classFileName;
    if (options.path != _defaultGeneratedClassPath && options.isPathCorrect) {
      extensions =
          '${options.path.replaceFirst(_defaultSourceFilesDirName, '')}'
          '/$extensions';
    }
    return {
      r'$lib$': [
        extensions,
      ]
    };
  }

  _GeneratorOptions get _generatorOptions {
    final optionsFile = File(_optionsFileName);

    if (optionsFile.existsSync()) {
      final optionsAsString = optionsFile.readAsStringSync();
      if (optionsAsString?.isNotEmpty ?? false) {
        return _GeneratorOptions.fromYamlMap(
          loadYaml(optionsAsString) as YamlMap,
        );
      }
    }

    return _GeneratorOptions();
  }

  Future<YamlMap> _createPubspecYampMap(BuildStep buildStep) async {
    final pubspecAssetId = AssetId(buildStep.inputId.package, _pubspecFileName);
    final pubspecAsString = await buildStep.readAsString(pubspecAssetId);
    return loadYaml(pubspecAsString) as YamlMap;
  }

  Future<String> _generateRFileContent(
    BuildStep buildStep,
    YamlMap pubspecYamlMap,
    _GeneratorOptions options,
  ) async {
    final assetPathsClass = await _createResourceClassString(
      pubspecYamlMap,
      buildStep,
      options.className,
    );

    final generatedFileContent = StringBuffer()
      ..writeln(_generatedFileHeader)
      ..write(assetPathsClass.toString());

    return generatedFileContent.toString();
  }

  Future<String> _createResourceClassString(
    YamlMap pubspecYamlMap,
    BuildStep buildStep,
    String className,
  ) async {
    final assetPaths =
        await _findAssetPathsFromPubspec(buildStep, pubspecYamlMap);
    final classBuffer = StringBuffer();
    if (assetPaths.isNotEmpty) {
      classBuffer
        ..writeln()
        ..writeln(_ignoreCommentForLinter)
        ..writeln('class $className {')
        ..writeln('  static const package = \'${buildStep.inputId.package}\';')
        ..writeln();
      for (final assetPath in assetPaths) {
        final propertyName = _createPropertyName(assetPath);

        if (propertyName.isNotEmpty) {
          classBuffer
            ..writeln('  /// ![](${path.absolute(assetPath)})')
            ..writeln('  static const $propertyName = \'$assetPath\';')
            ..writeln();
        }
      }

      classBuffer.writeln('}');
    }

    return classBuffer.toString();
  }

  Future<List<String>> _findAssetPathsFromPubspec(
    BuildStep buildStep,
    YamlMap pubspecYamlMap,
  ) async {
    final globList = _getUniqueAssetsGlobsFromPubspec(pubspecYamlMap);
    log.info('globList = $globList');
    final assetsSet = <AssetId>{};

    for (final glob in globList) {
      final assets = await buildStep.findAssets(glob).toList();

      log.info('assets = $assets');
      assetsSet.addAll(assets);
    }

    return assetsSet.map((e) => e.path).toList();
  }

  Set<Glob> _getUniqueAssetsGlobsFromPubspec(YamlMap pubspecYamlMap) {
    final globList = <Glob>{};
    for (final asset in _getUniqueAssetsPathsFromPubspec(pubspecYamlMap)) {
      if (asset.endsWith('/')) {
        globList.add(Glob('$asset*'));
      } else {
        globList.add(Glob(asset));
      }
    }

    return globList;
  }

  Set<String> _getUniqueAssetsPathsFromPubspec(YamlMap pubspecYamlMap) {
    if (pubspecYamlMap.containsKey('flutter')) {
      final dynamic flutterMap = pubspecYamlMap['flutter'];
      if (flutterMap is YamlMap && flutterMap.containsKey('assets')) {
        final assetsList = flutterMap['assets'] as YamlList;
        return Set.from(assetsList);
      }
    }

    return {};
  }

  String _createPropertyName(String assetPath) {
    var propertyName = assetPath.substring(
      assetPath.indexOf('/') + 1,
      assetPath.lastIndexOf('.'),
    );
    if (propertyName.isEmpty) return propertyName; // ignore .DS_Store file

    if (_identifierRegExp.hasMatch(propertyName)) {
      propertyName = propertyName.replaceAll('/', '_');
    } else {
      propertyName = propertyName.replaceAllMapped(
        _invalidIdentifierCharecatersRegExp,
        (match) => '_',
      );
    }

    return propertyName;
  }
}
