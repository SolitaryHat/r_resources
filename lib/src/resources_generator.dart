import 'dart:async';
import 'dart:io';

import 'package:build/build.dart';
import 'package:flutter_resources/src/class_gen/image_class_generator.dart';
import 'package:flutter_resources/src/utils.dart';
import 'package:glob/glob.dart';
import 'package:yaml/yaml.dart';
import 'package:path/path.dart' as path;

const _defaultGeneratedClassPath = 'lib';
const _defaultSourceFilesDirName = 'lib/';
const _optionsFileName = 'flutter_resources_options.yaml';
const _pubspecFileName = 'pubspec.yaml';
const _generatedFileHeader =
    '/// THIS FILE IS GENERATED BY flutter_resources. DO NOT MODIFY MANULLY.';

const _ignoreCommentForLinter = '// ignore_for_file: '
    'always_specify_types,'
    'lines_longer_than_80_chars,'
    'non_constant_identifier_names,'
    'prefer_double_quotes';

class _GeneratorOptions {
  const _GeneratorOptions._({
    this.path = _defaultGeneratedClassPath,
  });

  factory _GeneratorOptions() => const _GeneratorOptions._();

  factory _GeneratorOptions.fromYamlMap(YamlMap yamlMap) {
    return _GeneratorOptions._(
      path: yamlMap['path'] as String ?? _defaultGeneratedClassPath,
    );
  }

  final String path;

  bool get isPathCorrect =>
      path == _defaultGeneratedClassPath ||
      path.startsWith(_defaultSourceFilesDirName);
}

class ResourcesBuilder implements Builder {
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final pubspecYamlMap = await _createPubspecYampMap(buildStep);
    if (pubspecYamlMap?.isEmpty ?? true) return;

    final options = _generatorOptions;
    if (!options.isPathCorrect) {
      log.severe(
        'Overriden path from $_optionsFileName should start with "lib/"',
      );
      return;
    }

    final rClass = await _generateRFileContent(
      buildStep,
      pubspecYamlMap,
      options,
    );
    if (rClass.isEmpty) return;

    final dir = options.path.startsWith('lib') ? options.path : 'lib';
    final output = AssetId(
      buildStep.inputId.package,
      path.join(dir, 'r.dart'),
    );
    return buildStep.writeAsString(output, rClass);
  }

  @override
  Map<String, List<String>> get buildExtensions {
    final options = _generatorOptions;
    var extensions = 'r.dart';
    if (options.path != _defaultGeneratedClassPath && options.isPathCorrect) {
      extensions =
          '${options.path.replaceFirst(_defaultSourceFilesDirName, '')}'
          '/$extensions';
    }
    return {
      r'$lib$': [
        extensions,
      ]
    };
  }

  _GeneratorOptions get _generatorOptions {
    final optionsFile = File(_optionsFileName);

    if (optionsFile.existsSync()) {
      final optionsAsString = optionsFile.readAsStringSync();
      if (optionsAsString?.isNotEmpty ?? false) {
        return _GeneratorOptions.fromYamlMap(
          loadYaml(optionsAsString) as YamlMap,
        );
      }
    }

    return _GeneratorOptions();
  }

  Future<YamlMap> _createPubspecYampMap(BuildStep buildStep) async {
    final pubspecAssetId = AssetId(buildStep.inputId.package, _pubspecFileName);
    final pubspecAsString = await buildStep.readAsString(pubspecAssetId);
    return loadYaml(pubspecAsString) as YamlMap;
  }

  Future<String> _generateRFileContent(
    BuildStep buildStep,
    YamlMap pubspecYamlMap,
    _GeneratorOptions options,
  ) async {
    final assetPathList = await _findAssetPathsFromPubspec(
      buildStep,
      pubspecYamlMap,
    );

    final imagesClassGenerator = ImageClassGenerator(
      assetPathList: assetPathList,
    );
    final imageResourcesClass = await imagesClassGenerator.generate();

    final generatedFileContent = StringBuffer()
      ..writeln(_generatedFileHeader)
      ..writeln()
      ..writeln(_ignoreCommentForLinter)
      ..writeln('class R {');

    if (imageResourcesClass.isNotEmpty) {
      generatedFileContent.writeln(
        '  static final images = ${imagesClassGenerator.className}();',
      );
    }

    generatedFileContent..writeln('}')..writeln();

    if (imageResourcesClass.isNotEmpty) {
      generatedFileContent.write(imageResourcesClass);
    }

    generatedFileContent.writeln();
    return generatedFileContent.toString();
  }

  Future<List<String>> _findAssetPathsFromPubspec(
    BuildStep buildStep,
    YamlMap pubspecYamlMap,
  ) async {
    final globList = _getUniqueAssetsGlobsFromPubspec(pubspecYamlMap);
    final assetsSet = <AssetId>{};

    for (final glob in globList) {
      final assets = await buildStep.findAssets(glob).toList();
      assetsSet.addAll(
        assets.where(
          // remove invisible files: .gitignore, .DS_Store, etc.
          (it) => it.pathSegments.last.fileName.isNotEmpty,
        ),
      );
    }

    return assetsSet.map((it) => it.path).toList();
  }

  Set<Glob> _getUniqueAssetsGlobsFromPubspec(YamlMap pubspecYamlMap) {
    final globList = <Glob>{};
    for (final asset in _getUniqueAssetsPathsFromPubspec(pubspecYamlMap)) {
      if (asset.endsWith('/')) {
        globList.add(Glob('$asset*'));
      } else {
        globList.add(Glob(asset));
      }
    }

    return globList;
  }

  Set<String> _getUniqueAssetsPathsFromPubspec(YamlMap pubspecYamlMap) {
    if (pubspecYamlMap.containsKey('flutter')) {
      final dynamic flutterMap = pubspecYamlMap['flutter'];
      if (flutterMap is YamlMap && flutterMap.containsKey('assets')) {
        final assetsList = flutterMap['assets'] as YamlList;
        return Set.from(assetsList);
      }
    }

    return {};
  }
}
